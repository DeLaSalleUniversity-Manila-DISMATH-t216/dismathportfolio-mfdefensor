#My DISMATH Portfolio.
A pile of the weekly insights which registered on my mind.

# Week 1
It is said that logic is used to understand software and hardware. Propositional logic is statement or argument that is in declarative form, which may be answered by true and false only. The logical operators are the negation (NOT, opposite of the value), conjunction (AND, only true when all values are true), disjunction (OR, only false when all values are false), exclusive or (XOR, only true if only one value of all values are true), conditional (consists of a condition and a conclusion), and biconditional (iff, only true when all values have the same value regardless if it is true or false).

# Week 2
Compound propositions are English sentences turned into logical statements. Logical equivalences have compound propositions that holds true for all cases. Tautology gives true results regardless of the value, while contradiction gives false results regardless of the values.

# Week 3
The formal verification is proving arguments. It can be software or hardware. There are six formal verification methods. 3 of them were discussed this week: Direct Proof, Proof by Contraposition, Vacuous and Trivial Proof.
Direct proof is proving conditional statement by assuming the condition (first statement) to be true, and showing that the result (second statement) is also true by using the first statement. Proof by contraposition is proving a conditional statement by contrapositive structure--that is to say, the statements are interchanged--which means, the condition becomes the conclusion, and the conclusion becomes a condition--and each of them are negated, and like direct proof, the first statement (which is then the conclusion turned condition) is assumed true, and the second statement (the condition turned conclusion) should be shown as true using the first statement. The vacuous and trivial proof came from implication. Vacuous proof must show that the condition is false so that the conditional statement must be true. On the other hand, trivial proof shows that the conclusion is true so that the conditional statement must also be true. So far, my favorite of the methods is the direct proof, and I find the vacuous proof quite confusing.

# Week 4
The discussion of formal verification was continued this week. Proving by Contradiction requires making an assumption first, and then abandoning that assumption later. This method uses a single statement. That statement is negated first which is assumed to be true, and then showing that this assumption ends in contradiction. Proof by Equivalence proves a biconditional statement by directly proving it first as a conditional statement and second as an inverse conditional statement.
A new topic has been introduced. Mathematical Induction is substitution with direct proof by first making a basis of subsituting the first value (1) into the proposition, and then applying the inductive steps by proving that substituting k into the proposition gives k+1.

# Week 5
Recursive definition is defining a function in terms of itself. Recursive algorithm is the set of precise instructions for computations, which has a basis step by specifying the value of the function at zero, and a recursive step by giving a rule for finding its value at an integer. Program correcteness was also discussed. A program is said to be correct if the correct answer is obtained if the program terminates, and program should always terminate. It makes use of the Hoare Triple, which has Initial Assertion, which is assumed to be true, Program Segment, which is where the initial assertion is to be substituted, and the Final Assertion, which is shown to be true. There are also rules of inference which states that the program should be split into subprograms. Conditional and if-else statements utilizes Hoare Triple.

# Week 6
On this week I learned about fuctions as power series: converting series into functions and translating functions into series. Kinds of set were introduced on this week. I learned about null set (contains no elements), subset, superset--also integer is a subset of real numbers, and real number is a superset of integer--and power set--the set of all subsets. I also learned further that an empty set is a subset, and cardinality is the number of elements. It is known that |{ a, b, c, d, e}|=5 and |{{a,b}, {c,d,e,f,g}, {h}}|=3. While reviewing for the quiz, it was mentioned that nested quantifer is not the same as cascades of codes in C programming, which are executed sequentially.

# Week 7
Functions were introduced this week. Functions have one domain for a value of range. There can never be same domains in a function. The difference of range and codomain was elaborated: range is the actual value, while codomain describes the whole, or the set itself. What made me understand it fully is the illustration using C programming "int floor(float x)", where "int", the data type of the return value, is the codomain. It might be said that the "floor()" is the range, for a value of a float x. Anyways, there are 3 kinds of functions that were introduced: injective--a one to one relationship, surjective--where all values in codomain are used, and bijection--the combination of injective and surjective. It was further discussed that in injective, there should be no common range for two values of domain.

# Week 8
We have discussed about algorithms and it's something that I find confusing. Anyways, I learned that Google and Facebook had used algorithms, and good ones, too. Algorith is a language for machines to understand what the humans are conveying, since machines do not eat, sleep nor get bored. It utilizes the same conditions as that of program correctness: precondition, the input, and postcondition, the output. Some examples discussed were for the program to find for the largest number, and for the program to search for the location of the element inputted by the user, or the linear search. We also learned that if algorithm is a machine language, pseudocode is a high level description algorithm intended for human understanding, meaning, somehow, it's much simpler than algorithm.

# Week 9
We have further discussed about algorithms such as bubble sort-which sorts one by one the elements and compare each of them who is greater and they will be swapped, linear and binary searches-linear looks through all the elements one by one to search for the desired location of the element and binary search is a search which contains increasing ordered elements and divides them into two and compares it with the searching element excludes one of the half and the same process is repeated again, insertion sort--makes the first element permanent then one by one the succeeding elements will go through the beginning and find their position, and greedy algorithm-chooses the most efficient combination of elements, mostly the largest deriving its name "greedy". We also discussed about the growth of functions and time complexity. Big-O notation discussion the upperbound function, big-omega the lower bound, and big-theta both bounds. Time complexity is all about the number of comparisons and the time it takes for a process to be finished.
